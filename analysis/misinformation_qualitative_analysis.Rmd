---
title: "Qualitative Analysis of Diana Daly's Pilot Study"
subtitle: "(Plots of Preliminary Findings)"
author: "Kendall Beaver"
date: "`r Sys.Date()`"
output: pdf_document
---

```{r setup, tidy=TRUE, message=FALSE, warning=FALSE, results='hide', echo=FALSE}

# Load library and dataset

#install.packages("rmarkdown")
#install.packages("tinytex")
#tinytex::install_tinytex()
#install.packages("gridExtra")
#install.packages("cowplot")

library(gridExtra)
library(readxl)
library(dplyr)
library(corrplot)
library(writexl)
library(ggplot2)

misinfo <- read_excel("data/sketches_for_skepticism_shortened.xlsx")
summary(misinfo)
```

```{r filtered_data, tidy=TRUE, message=FALSE, warning=FALSE, results='hide', echo=FALSE}

# Filtered data set to columns I need

# Columns I need: 

# PARTICIPANT ID
# GROUP
# CHANGED_VIEWS_QQ1
# CHANGED_LENGTH_QQ1
# CHANGED_VIEWS_QQ2
# CHANGED_LENGTH_QQ2
# GCBS PRE SCORE
# GCBS POST SCORE
# PRE & POST SCORE
# GCBS CHANGE
# MIST-20 PRE SCORE
# MIST-20 POST SCORE
# MIST-20 CHANGE
# ITMIST PRE SCORE
# ITMIST POST SCORE
# ITMIST CHANGE
# UNDERSTANDABILITY
# SENTIMENT
# ADDITIONAL THOUGHTS

misinfo_filtered <- misinfo %>%
  select(`PARTICIPANT ID`, GROUP, CHANGED_VIEWS_QQ1, CHANGED_LENGTH_QQ1,
         CHANGED_VIEWS_QQ2, CHANGED_LENGTH_QQ2, `GCBS PRE SCORE`, 
         `GCBS POST SCORE`, `PRE & POST SCORE`, `GCBS CHANGE`, 
         `MIST-20 PRE SCORE`, `MIST-20 POST SCORE`, `MIST-20 CHANGE`, 
         `ITMIST PRE SCORE`, `ITMIST POST SCORE`, `ITMIST CHANGE`, 
         UNDERSTANDABILITY, SENTIMENT, `ADDITIONAL THOUGHTS`)
```

```{r factors, tidy=TRUE, message=FALSE, warning=FALSE, results='hide', echo=FALSE}
# Turn "character" columns into factors

# Columns that need to be turned into factors: 

# GROUP
#   "Test Group (Visual)"
#   "Control Group (Visual)"
#   "Test Group (Audio)"
#   "Control Group (Audio)"

# CHANGED_VIEWS_QQ1
#   "View stayed about the same"
#   "View had some/moderate change"
#   "View significantantly changed"

# CHANGED_LENGTH_QQ1
#   "Comment length became slightly or significantly shorter"
#   "Comment length became slightly or significantly longer" 
#   "Comment length stayed about the same"

# CHANGED_VIEWS_QQ2

# CHANGED_LENGTH_QQ2

# UNDERSTANDABILITY

# SENTIMENT

# `ADDITIONAL THOUGHTS`

# Mapping categorical variables to numerical values
misinfo_filtered <- misinfo_filtered %>%
  mutate(
    GROUP = case_when(
      GROUP == "Test Group (Visual)" ~ 1,
      GROUP == "Control Group (Visual)" ~ 2,
      GROUP == "Test Group (Audio)" ~ 3,
      GROUP == "Control Group (Audio)" ~ 4
    ),
    CHANGED_VIEWS_QQ1 = case_when(
      CHANGED_VIEWS_QQ1 == "View stayed about the same" ~ 1,
      CHANGED_VIEWS_QQ1 == "View had some/moderate change" ~ 2,
      CHANGED_VIEWS_QQ1 == "View significantly changed" ~ 3
    ),
    CHANGED_LENGTH_QQ1 = case_when(
      CHANGED_LENGTH_QQ1 == "Comment length became slightly or significantly shorter" ~ 1,
      CHANGED_LENGTH_QQ1 == "Comment length became slightly or significantly longer" ~ 2,
      CHANGED_LENGTH_QQ1 == "Comment length stayed about the same" ~ 3
    ),
    CHANGED_VIEWS_QQ2 = case_when(
      CHANGED_VIEWS_QQ2 == "View stayed about the same" ~ 1,
      CHANGED_VIEWS_QQ2 == "View had some/moderate change" ~ 2,
      CHANGED_VIEWS_QQ2 == "View significantly changed" ~ 3
    ),
    CHANGED_LENGTH_QQ2 = case_when(
      CHANGED_LENGTH_QQ2 == "Comment length became slightly or significantly shorter" ~ 1,
      CHANGED_LENGTH_QQ2 == "Comment length became slightly or significantly longer" ~ 2,
      CHANGED_LENGTH_QQ2 == "Comment length stayed about the same" ~ 3
    ),
    SENTIMENT = case_when(
      SENTIMENT == "Positive" ~ 1,
      SENTIMENT == "Negative" ~ 2,
      SENTIMENT == "Neutral" ~ 3
    )
  )

# Check the updated dataset
head(misinfo_filtered)

# Check for missing values in the dataset
colSums(is.na(misinfo_filtered))

# Ensure CHANGED_VIEWS_QQ1 is treated as a factor
#misinfo_filtered$CHANGED_VIEWS_QQ1 <- as.factor(misinfo_filtered$CHANGED_VIEWS_QQ1)

# Ensure CHANGED_LENGTH_QQ1 is treated as a factor
#misinfo_filtered$CHANGED_LENGTH_QQ1 <- as.factor(misinfo_filtered$CHANGED_LENGTH_QQ1)

# Ensure SENTIMENT is treated as a factor
#misinfo_filtered$SENTIMENT <- as.factor(misinfo_filtered$SENTIMENT)
```

```{r pie_chart, tidy=TRUE, message=FALSE, warning=FALSE, results='hide', echo=FALSE, fig.align='center', results='asis'}

library(ggplot2)
library(dplyr)

# Create an empty list to store pie charts
pie_charts <- list()

# Define a vector to map numeric values to descriptions for CHANGED_VIEWS_QQ1
view_labels <- c("1" = "View stayed about the same",
                 "2" = "View had some/moderate change",
                 "3" = "View significantly changed")

# Custom colors for each section (You can change these to any colors you prefer)
#custom_colors <- c("skyblue", "lightgreen", "coral")
custom_colors <- c("skyblue", "orange", "red")

# Define a vector to map numeric GROUP values to their corresponding titles
group_titles <- c(
  "1" = "Test Group (Visual)",
  "2" = "Control Group (Visual)",
  "3" = "Test Group (Audio)",
  "4" = "Control Group (Audio)"
)

# Loop through each GROUP value (numeric) and create pie charts
for (group_value in unique(misinfo_filtered$GROUP)) {
  
  # Convert group_value to a character (because group_titles uses character keys)
  group_name <- as.character(group_value)
  
  # Prepare data for pie chart
  pie_data <- misinfo_filtered %>%
    filter(GROUP == group_value) %>%
    count(CHANGED_VIEWS_QQ1) %>%
    mutate(percentage = n / sum(n) * 100,
           label = paste0(round(percentage, 1), "%"))  # Create labels with percentage signs
  
  # Ensure CHANGED_VIEWS_QQ1 is a factor
  pie_data$CHANGED_VIEWS_QQ1 <- factor(pie_data$CHANGED_VIEWS_QQ1, levels = c("1", "2", "3"))
  
  # Generate pie chart with custom colors and black borders
  p <- ggplot(pie_data, aes(x = "", y = n, fill = CHANGED_VIEWS_QQ1)) +
    geom_bar(stat = "identity", width = 1, color = "black") +  # Add black border around sections
    coord_polar(theta = "y") +
    geom_text(aes(label = label), position = position_stack(vjust = 0.7), color = "black", size = 3, fontface = "bold") +  # Add labels inside the pie
    labs(title = group_titles[group_name],  # Custom title based on group_name
         fill = "Change in Views") +  # Rename the legend
    scale_fill_manual(values = custom_colors, labels = view_labels) +  # Apply custom colors
    theme_void() +  # Remove unnecessary gridlines
    theme(legend.position = "right")  # Ensure the legend is visible
  
  # Store the plot in the list with the group value as the name
  pie_charts[[paste0("Group_", group_name)]] <- p
}

# View stored pie charts
#pie_charts[["Group_1"]]  # View the pie chart for "Test Group (Visual)"
#pie_charts[["Group_2"]]  # View the pie chart for "Control Group (Visual)"
#pie_charts[["Group_3"]]  # View the pie chart for "Test Group (Audio)"
#pie_charts[["Group_4"]]  # View the pie chart for "Control Group (Audio)"

# Combine the first two and the last two pie charts in a 2x2 grid
#grid.arrange(
#  pie_charts[["Group_1"]],  # Test Group (Visual)
#  pie_charts[["Group_2"]]  # Control Group (Visual)
  #pie_charts[["Group_3"]],  # Test Group (Audio)
  #pie_charts[["Group_4"]],  # Control Group (Audio)
  #nrow = 2  # Arrange in 2 rows
  #ncol = 1   # Arrange in 2 columns
#)
```

```{r four_pie_charts_in_one, tidy=TRUE, message=FALSE, warning=FALSE, results='hide', echo=FALSE, fig.align='center', results='asis'}

library(gridExtra)
library(cowplot)

# Function to extract the legend from a ggplot
get_legend <- function(my_plot) {
  g <- ggplotGrob(my_plot)
  legend <- g$grobs[[which(sapply(g$grobs, function(x) x$name) == "guide-box")]]
  return(legend)
}

# Extract the legend from one of the pie charts
shared_legend <- get_legend(pie_charts[["Group_1"]])

# Apply centered titles to all four plots
plot1 <- pie_charts[["Group_1"]] +
  ggtitle("Test Group (Visual)") +
  theme(plot.title = element_text(hjust = 0.5), legend.position = "none")

plot2 <- pie_charts[["Group_2"]] +
  ggtitle("Control Group (Visual)") +
  theme(plot.title = element_text(hjust = 0.5), legend.position = "none")

plot3 <- pie_charts[["Group_3"]] +
  ggtitle("Test Group (Audio)") +
  theme(plot.title = element_text(hjust = 0.5), legend.position = "none")

plot4 <- pie_charts[["Group_4"]] +
  ggtitle("Control Group (Audio)") +
  theme(plot.title = element_text(hjust = 0.5), legend.position = "none")

# Arrange first row (Visual groups)
#row1 <- arrangeGrob(plot1, plot2, nrow = 1)

# Arrange second row (Audio groups)
#row2 <- arrangeGrob(plot3, plot4, nrow = 1)

# Arrange everything correctly
#grid.arrange(
#  row1,
#  row2,
#  shared_legend,
#  nrow = 3,
#  heights = c(4, 4, 2)  # Adjust height ratios for better spacing
#)

```

```{r visual_ad_pie_charts, tidy=TRUE, message=FALSE, warning=FALSE, results='hide', echo=FALSE, fig.align='center', results='asis'}

library(gridExtra)
library(cowplot)

# Function to extract the legend from a ggplot
get_legend <- function(my_plot) {
  g <- ggplotGrob(my_plot)
  legend <- g$grobs[[which(sapply(g$grobs, function(x) x$name) == "guide-box")]]
  return(legend)
}

# Extract the legend from one of the pie charts
shared_legend <- get_legend(pie_charts[["Group_1"]])

# Apply centered titles to all four plots
plot1 <- pie_charts[["Group_1"]] +
  ggtitle("Test Group") +
  theme(plot.title = element_text(hjust = 0.5), legend.position = "none") # Visual Test Group

plot2 <- pie_charts[["Group_2"]] +
  ggtitle("Control Group") +
  theme(plot.title = element_text(hjust = 0.5), legend.position = "none") # Visual Control Group

plot3 <- pie_charts[["Group_3"]] +
  ggtitle("Test Group") +
  theme(plot.title = element_text(hjust = 0.5), legend.position = "none") # Audio Test Group

plot4 <- pie_charts[["Group_4"]] +
  ggtitle("Control Group") +
  theme(plot.title = element_text(hjust = 0.5), legend.position = "none") # Audio Control Group

#grid.arrange(
#  arrangeGrob(
#    plot1, plot2,
#    nrow = 1
#  ),
#  shared_legend,
#  nrow = 2,
#  heights = c(4, 2)  # Adjust height ratios for better spacing
#)
```

```{r audio_ad_pie_charts, tidy=TRUE, message=FALSE, warning=FALSE, results='hide', echo=FALSE, fig.align='center', results='asis'}

#grid.arrange(
#  arrangeGrob(
#    plot3, plot4,
#    nrow = 1
#  ),
#  shared_legend,
#  nrow = 2,
#  heights = c(4, 2)  # Adjust height ratios for better spacing
#)

# heights = c(4, 1)  # Original ratio
```

```{r answer_length_1, tidy=TRUE, message=FALSE, warning=FALSE, results='hide', echo=FALSE, fig.align='center', results='asis'}

# THIS IS JUST THE CODE TO PERFORM THE ANALYSIS ON COMMENT LENGTH

# Create an empty list to store pie charts
pie_charts <- list()

# Define a vector to map numeric values to descriptions for CHANGED_VIEWS_QQ1
view_labels <- c("1" = "Comment length stayed about the same",
                 "2" = "Comment length became slightly or significantly longer",
                 "3" = "Comment length became slightly or significantly shorter")

# Custom colors for each section (You can change these to any colors you prefer)
#custom_colors <- c("skyblue", "lightgreen", "coral")
custom_colors <- c("skyblue", "red", "orange")

# Define a vector to map numeric GROUP values to their corresponding titles
group_titles <- c(
  "1" = "Test Group (Visual)",
  "2" = "Control Group (Visual)",
  "3" = "Test Group (Audio)",
  "4" = "Control Group (Audio)"
)

# Loop through each GROUP value (numeric) and create pie charts
for (group_value in unique(misinfo_filtered$GROUP)) {
  
  # Convert group_value to a character (because group_titles uses character keys)
  group_name <- as.character(group_value)
  
  # Prepare data for pie chart
  pie_data <- misinfo_filtered %>%
    filter(GROUP == group_value) %>%
    count(CHANGED_LENGTH_QQ1) %>%
    mutate(percentage = n / sum(n) * 100,
           label = paste0(round(percentage, 1), "%"))  # Create labels with percentage signs
  
  # Ensure CHANGED_VIEWS_QQ1 is a factor
  pie_data$CHANGED_LENGTH_QQ1 <- factor(pie_data$CHANGED_LENGTH_QQ1, levels = c("1", "2", "3"))
  
  # Generate pie chart with custom colors and black borders
  p <- ggplot(pie_data, aes(x = "", y = n, fill = CHANGED_LENGTH_QQ1)) +
    geom_bar(stat = "identity", width = 1, color = "black") +  # Add black border around sections
    coord_polar(theta = "y") +
    geom_text(aes(label = label), position = position_stack(vjust = 0.7), color = "black", size = 3, fontface = "bold") +  # Add labels inside the pie
    labs(title = group_titles[group_name],  # Custom title based on group_name
         fill = "Change in Comment Length") +  # Rename the legend
    scale_fill_manual(values = custom_colors, labels = view_labels) +  # Apply custom colors
    theme_void() +  # Remove unnecessary gridlines
    theme(legend.position = "right")  # Ensure the legend is visible
  
  # Store the plot in the list with the group value as the name
  pie_charts[[paste0("Group_", group_name)]] <- p
}

# The first two pie charts


# Function to extract the legend from a ggplot
get_legend <- function(my_plot) {
  g <- ggplotGrob(my_plot)
  legend <- g$grobs[[which(sapply(g$grobs, function(x) x$name) == "guide-box")]]
  return(legend)
}

# Extract the legend from one of the pie charts
shared_legend <- get_legend(pie_charts[["Group_1"]])

# Apply centered titles to all four plots
plot1 <- pie_charts[["Group_1"]] +
  ggtitle("Test Group") +
  theme(plot.title = element_text(hjust = 0.5), legend.position = "none") # Visual Test Group

plot2 <- pie_charts[["Group_2"]] +
  ggtitle("Control Group") +
  theme(plot.title = element_text(hjust = 0.5), legend.position = "none") # Visual Control Group

plot3 <- pie_charts[["Group_3"]] +
  ggtitle("Test Group") +
  theme(plot.title = element_text(hjust = 0.5), legend.position = "none") # Audio Test Group

plot4 <- pie_charts[["Group_4"]] +
  ggtitle("Control Group") +
  theme(plot.title = element_text(hjust = 0.5), legend.position = "none") # Audio Control Group

#grid.arrange(
#  arrangeGrob(
#    plot1, plot2,
#    nrow = 1
#  ),
#  shared_legend,
#  nrow = 2,
#  heights = c(4, 2)  # Adjust height ratios for better spacing
#)
```

# **QQ1 - Content of Answer**

*What are some reasons you think people are attracted to radical groups?*

```{r bar_chart_1, tidy=TRUE, message=FALSE, warning=FALSE, results='hide', echo=FALSE, fig.align='center', results='asis'}

# Prepare data for stacked bar chart
stacked_data <- misinfo_filtered %>%
  count(GROUP, CHANGED_VIEWS_QQ1) %>%
  group_by(GROUP) %>%
  mutate(percentage = n / sum(n) * 100) %>%  # Convert to percentage
  ungroup()

# Ensure GROUP and CHANGED_LENGTH_QQ1 are factors for proper ordering
stacked_data$GROUP <- factor(stacked_data$GROUP, levels = c("1", "2", "3", "4"))
stacked_data$CHANGED_VIEWS_QQ1 <- factor(stacked_data$CHANGED_VIEWS_QQ1, levels = c("1", "2", "3"))

# Define custom labels for groups
group_titles <- c(
  "1" = "Test Group (Visual)",
  "2" = "Control Group (Visual)",
  "3" = "Test Group (Audio)",
  "4" = "Control Group (Audio)"
)

# Define a vector to map numeric values to descriptions for CHANGED_VIEWS_QQ1
view_labels <- c("1" = "View stayed about the same",
                 "2" = "View had some/moderate change",
                 "3" = "View significantly changed")

# Custom colors
custom_colors <- c("skyblue", "orange", "red")

# Create the stacked bar chart
stacked_bar_chart <- ggplot(stacked_data, aes(x = GROUP, y = percentage, fill = CHANGED_VIEWS_QQ1)) +
  geom_bar(stat = "identity", color = "black") +  # Stacked bars with black borders
  geom_text(aes(label = paste0(round(percentage, 1), "%")), 
            position = position_stack(vjust = 0.5),  # Position labels in center of bars
            color = "black", size = 4) +  # Adjust label size and color
  labs(
    title = "Change in QQ1 Answer After Exposed to Ad",
    x = "\nGroup",
    y = "Percentage\n",
    fill = "Answer"
  ) +
  scale_x_discrete(labels = group_titles) +  # Map numeric groups to names
  scale_fill_manual(values = custom_colors, labels = view_labels) +  # Apply colors and labels
  theme_minimal() + 
  theme(
    plot.title = element_text(hjust = 0.5, size = 14, face = "bold"),  # Center and style the title
    axis.text.x = element_text(angle = 30, hjust = 1),  # Tilt x-axis labels for readability
    legend.position = "right",  # Keep legend visible
    legend.title = element_text(face = "bold"),
    legend.text = element_text(size = 10)
  )

# Print the stacked bar chart
print(stacked_bar_chart)
```

\newpage

# **QQ1 - Length of Answer**

*What are some reasons you think people are attracted to radical groups?*

```{r bar_chart_2, tidy=TRUE, message=FALSE, warning=FALSE, results='hide', echo=FALSE, fig.align='center', results='asis'}

# Load necessary libraries
library(ggplot2)
library(dplyr)

# Prepare data for stacked bar chart
stacked_data <- misinfo_filtered %>%
  count(GROUP, CHANGED_LENGTH_QQ1) %>%
  group_by(GROUP) %>%
  mutate(percentage = n / sum(n) * 100) %>%  # Convert to percentage
  ungroup()

# Ensure GROUP and CHANGED_LENGTH_QQ1 are factors for proper ordering
stacked_data$GROUP <- factor(stacked_data$GROUP, levels = c("1", "2", "3", "4"))
stacked_data$CHANGED_LENGTH_QQ1 <- factor(stacked_data$CHANGED_LENGTH_QQ1, levels = c("1", "2", "3"))

# Define custom labels for groups
group_titles <- c(
  "1" = "Test Group (Visual)",
  "2" = "Control Group (Visual)",
  "3" = "Test Group (Audio)",
  "4" = "Control Group (Audio)"
)

# Define labels for CHANGED_LENGTH_QQ1
view_labels <- c("1" = "Length stayed about the same",
                 "2" = "Length became longer",
                 "3" = "Length became shorter")

# Custom colors
custom_colors <- c("skyblue", "red", "orange")

# Create the stacked bar chart
stacked_bar_chart <- ggplot(stacked_data, aes(x = GROUP, y = percentage, fill = CHANGED_LENGTH_QQ1)) +
  geom_bar(stat = "identity", color = "black") +  # Stacked bars with black borders
  geom_text(aes(label = paste0(round(percentage, 1), "%")), 
            position = position_stack(vjust = 0.5),  # Position labels in center of bars
            color = "black", size = 4) +  # Adjust label size and color
  labs(
    title = "Change in QQ1 Comment Length After\nExposed to Ad",
    x = "\nGroup",
    y = "Percentage\n",
    fill = "Comment Length"
  ) +
  scale_x_discrete(labels = group_titles) +  # Map numeric groups to names
  scale_fill_manual(values = custom_colors, labels = view_labels) +  # Apply colors and labels
  theme_minimal() + 
  theme(
    plot.title = element_text(hjust = 0.5, size = 14, face = "bold"),  # Center and style the title
    axis.text.x = element_text(angle = 30, hjust = 1),  # Tilt x-axis labels for readability
    legend.position = "right",  # Keep legend visible
    legend.title = element_text(face = "bold"),
    legend.text = element_text(size = 10)
  )

# Print the stacked bar chart
print(stacked_bar_chart)
```

\newpage

# **QQ2 - Content of Answer**

*What are some reasons you think people believe false ideas circulating online?*

```{r bar_chart_3, tidy=TRUE, message=FALSE, warning=FALSE, results='hide', echo=FALSE, fig.align='center', results='asis'}

library(tidyr)  # Ensure tidyr is loaded for drop_na()

# Prepare data for stacked bar chart
stacked_data <- misinfo_filtered %>%
  drop_na(CHANGED_VIEWS_QQ2) %>%  # Removes rows with NA in CHANGED_VIEWS_QQ2
  count(GROUP, CHANGED_VIEWS_QQ2) %>%
  group_by(GROUP) %>%
  mutate(percentage = n / sum(n) * 100) %>%  # Convert to percentage
  ungroup()

# Ensure GROUP and CHANGED_VIEWS_QQ2 are factors for proper ordering
stacked_data$GROUP <- factor(stacked_data$GROUP, levels = c("1", "2", "3", "4"))
stacked_data$CHANGED_VIEWS_QQ2 <- factor(stacked_data$CHANGED_VIEWS_QQ2, levels = c("1", "2", "3"))

# Define custom labels for groups
group_titles <- c(
  "1" = "Test Group (Visual)",
  "2" = "Control Group (Visual)",
  "3" = "Test Group (Audio)",
  "4" = "Control Group (Audio)"
)

# Define a vector to map numeric values to descriptions for CHANGED_VIEWS_QQ2
view_labels <- c("1" = "View stayed about the same",
                 "2" = "View had some/moderate change",
                 "3" = "View significantly changed")

# Custom colors
custom_colors <- c("skyblue", "orange", "red")

# Create the stacked bar chart
stacked_bar_chart <- ggplot(stacked_data, aes(x = GROUP, y = percentage, fill = CHANGED_VIEWS_QQ2)) +
  geom_bar(stat = "identity", color = "black") +  # Stacked bars with black borders
  geom_text(aes(label = paste0(round(percentage, 1), "%")), 
            position = position_stack(vjust = 0.5),  # Position labels in center of bars
            color = "black", size = 4) +  # Adjust label size and color
  labs(
    title = "\nChange in QQ2 Answer After Exposed to Ad",
    x = "\nGroup",
    y = "Percentage\n",
    fill = "Answer"
  ) +
  scale_x_discrete(labels = group_titles) +  # Map numeric groups to names
  scale_fill_manual(values = custom_colors, labels = view_labels) +  # Apply colors and labels
  theme_minimal() + 
  theme(
    plot.title = element_text(hjust = 0.5, size = 14, face = "bold"),  # Center and style the title
    axis.text.x = element_text(angle = 30, hjust = 1),  # Tilt x-axis labels for readability
    legend.position = "right",  # Keep legend visible
    legend.title = element_text(face = "bold"),
    legend.text = element_text(size = 10)
  )

# Print the stacked bar chart
print(stacked_bar_chart)
```

\newpage

# **QQ2 - Length of Answer**

*What are some reasons you think people believe false ideas circulating online?*

```{r bar_chart_4, tidy=TRUE, message=FALSE, warning=FALSE, results='hide', echo=FALSE, fig.align='center', results='asis'}

# Load necessary libraries
library(ggplot2)
library(dplyr)
library(tidyr)  # Ensure tidyr is loaded for drop_na()

# Prepare data for stacked bar chart, removing NA values only for this analysis
stacked_data <- misinfo_filtered %>%
  drop_na(CHANGED_LENGTH_QQ2) %>%  # Removes rows with NA in CHANGED_LENGTH_QQ2
  count(GROUP, CHANGED_LENGTH_QQ2) %>%
  group_by(GROUP) %>%
  mutate(percentage = n / sum(n) * 100) %>%  # Convert to percentage
  ungroup()

# Ensure GROUP and CHANGED_LENGTH_QQ2 are factors for proper ordering
stacked_data$GROUP <- factor(stacked_data$GROUP, levels = c("1", "2", "3", "4"))
stacked_data$CHANGED_LENGTH_QQ2 <- factor(stacked_data$CHANGED_LENGTH_QQ2, levels = c("1", "2", "3"))

# Define custom labels for groups
group_titles <- c(
  "1" = "Test Group (Visual)",
  "2" = "Control Group (Visual)",
  "3" = "Test Group (Audio)",
  "4" = "Control Group (Audio)"
)

# Define labels for CHANGED_LENGTH_QQ2
view_labels <- c("1" = "Length stayed about the same",
                 "2" = "Length became longer",
                 "3" = "Length became shorter")

# Custom colors
custom_colors <- c("skyblue", "red", "orange")

# Create the stacked bar chart
stacked_bar_chart <- ggplot(stacked_data, aes(x = GROUP, y = percentage, fill = CHANGED_LENGTH_QQ2)) +
  geom_bar(stat = "identity", color = "black") +  # Stacked bars with black borders
  geom_text(aes(label = paste0(round(percentage, 1), "%")), 
            position = position_stack(vjust = 0.5),  # Position labels in center of bars
            color = "black", size = 4) +  # Adjust label size and color
  labs(
    title = "Change in QQ2 Comment Length After\nExposed to Ad",
    x = "\nGroup",
    y = "Percentage\n",
    fill = "Comment Length"
  ) +
  scale_x_discrete(labels = group_titles) +  # Map numeric groups to names
  scale_fill_manual(values = custom_colors, labels = view_labels) +  # Apply colors and labels
  theme_minimal() + 
  theme(
    plot.title = element_text(hjust = 0.5, size = 14, face = "bold"),  # Center and style the title
    axis.text.x = element_text(angle = 30, hjust = 1),  # Tilt x-axis labels for readability
    legend.position = "right",  # Keep legend visible
    legend.title = element_text(face = "bold"),
    legend.text = element_text(size = 10)
  )

# Print the stacked bar chart
print(stacked_bar_chart)
```

```{r test_box_plots, tidy=TRUE, message=FALSE, warning=FALSE, results='hide', echo=FALSE, fig.align='center', results='asis'}

# Create a box plot for GCBS PRE SCORE by GROUP
box_plot <- ggplot(misinfo_filtered, aes(x = as.factor(GROUP), y = `GCBS PRE SCORE`, fill = as.factor(GROUP))) +
  geom_boxplot(outlier.colour = "red", outlier.shape = 16, outlier.size = 2) +  # Boxplot with outliers in red
  labs(
    title = "Distribution of GCBS Pre Score by Group",
    x = "Group",
    y = "GCBS Pre Score"
  ) +
  scale_x_discrete(labels = group_titles) +  # Apply custom labels for groups
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, size = 14, face = "bold"),
    legend.position = "none"  # Hide legend since colors represent groups
  )

# Print the box plot
#print(box_plot)

# Create a box plot for GCBS POST SCORE by GROUP
box_plot_post <- ggplot(misinfo_filtered, aes(x = as.factor(GROUP), y = `GCBS POST SCORE`, fill = as.factor(GROUP))) +
  geom_boxplot(outlier.colour = "red", outlier.shape = 16, outlier.size = 2) +  # Boxplot with outliers in red
  labs(
    title = "Distribution of GCBS Post Score by Group",
    x = "Group",
    y = "GCBS Post Score"
  ) +
  scale_x_discrete(labels = group_titles) +  # Apply custom labels for groups
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, size = 14, face = "bold"),
    legend.position = "none"  # Hide legend since colors represent groups
  )

# Print the box plot
#print(box_plot_post)
```

```{r box_plot_1, tidy=TRUE, message=FALSE, warning=FALSE, results='hide', echo=FALSE, fig.align='center', results='asis'}

# Load necessary libraries
library(ggplot2)
library(dplyr)
library(tidyr)
library(gridExtra)

# Define custom labels for groups
group_titles <- c(
  "1" = "VISUAL AD", # Test Group (Visual)
  "2" = "VISUAL AD", # Control Group (Visual)
  "3" = "AUDIO AD", # Test Group (Audio)
  "4" = "AUDIO AD" # Control Group (Audio)
)

# Reshape the data to long format for easier faceting
long_data <- misinfo_filtered %>%
  select(GROUP, `GCBS PRE SCORE`, `GCBS POST SCORE`) %>%
  pivot_longer(cols = c(`GCBS PRE SCORE`, `GCBS POST SCORE`), 
               names_to = "Test_Time", 
               values_to = "Score") %>%
  mutate(Test_Time = factor(Test_Time, levels = c("GCBS PRE SCORE", "GCBS POST SCORE")))

# Create the first plot for Groups 1 and 2 (Visual Test and Control)
plot1 <- ggplot(long_data %>% filter(GROUP %in% c(1, 3)), aes(x = Test_Time, y = Score, fill = Test_Time)) +
  geom_boxplot(outlier.colour = "red", outlier.shape = 16, outlier.size = 2) +
  facet_wrap(~ GROUP, labeller = as_labeller(group_titles)) +  # Only for Groups 1 and 2
  labs(
    title = "GCBS Scores Before & After Ad - Test Group\n",
    x = "\nGCBS Test Scores",
    y = "Score\n"
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, size = 14, face = "bold"),
    legend.position = "none"
  )

# Use grid.arrange to display both plots together
grid.arrange(plot1)  # Arrange plots side by side
```

```{r box_plot_2, tidy=TRUE, message=FALSE, warning=FALSE, results='hide', echo=FALSE, fig.align='center', results='asis'}

# Load necessary libraries
library(ggplot2)
library(dplyr)
library(tidyr)
library(gridExtra)

# Define custom labels for groups
group_titles <- c(
  "1" = "VISUAL AD", # Test Group (Visual)
  "2" = "VISUAL AD", # Control Group (Visual)
  "3" = "AUDIO AD", # Test Group (Audio)
  "4" = "AUDIO AD" # Control Group (Audio)
)

# Reshape the data to long format for easier faceting
long_data <- misinfo_filtered %>%
  select(GROUP, `GCBS PRE SCORE`, `GCBS POST SCORE`) %>%
  pivot_longer(cols = c(`GCBS PRE SCORE`, `GCBS POST SCORE`), 
               names_to = "Test_Time", 
               values_to = "Score") %>%
  mutate(Test_Time = factor(Test_Time, levels = c("GCBS PRE SCORE", "GCBS POST SCORE")))

# Create the plot for Groups 2 and 4 (Control Group)
plot2 <- ggplot(long_data %>% filter(GROUP %in% c(2, 4)), aes(x = Test_Time, y = Score, fill = Test_Time)) +
  geom_boxplot(outlier.colour = "red", outlier.shape = 16, outlier.size = 2) +
  facet_wrap(~ GROUP, labeller = as_labeller(group_titles)) +  # Only for Groups 2 and 4
  labs(
    title = "GCBS Scores Before & After Ad - Control Group\n",
    x = "\nGCBS Test Scores",
    y = "Score\n"
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, size = 14, face = "bold"),
    legend.position = "none"
  )

# Use grid.arrange to display the plot
grid.arrange(plot2)  # Display the plot for Control Groups (2 & 4)
```

```{r mist_1, tidy=TRUE, message=FALSE, warning=FALSE, results='hide', echo=FALSE, fig.align='center', results='asis'}

# Define custom labels for groups
group_titles <- c(
  "1" = "VISUAL AD", # Test Group (Visual)
  "2" = "VISUAL AD", # Control Group (Visual)
  "3" = "AUDIO AD", # Test Group (Audio)
  "4" = "AUDIO AD" # Control Group (Audio)
)

# Reshape the data to long format for easier faceting
long_data <- misinfo_filtered %>%
  # Convert both "MIST-20 PRE SCORE" and "MIST-20 POST SCORE" to numeric
  mutate(
    `MIST-20 PRE SCORE` = as.numeric(`MIST-20 PRE SCORE`),
    `MIST-20 POST SCORE` = as.numeric(`MIST-20 POST SCORE`)
  ) %>%
  select(GROUP, `MIST-20 PRE SCORE`, `MIST-20 POST SCORE`) %>%  # Updated column names here
  pivot_longer(cols = c(`MIST-20 PRE SCORE`, `MIST-20 POST SCORE`), 
               names_to = "Test_Time", 
               values_to = "Score") %>%
  mutate(Test_Time = factor(Test_Time, levels = c("MIST-20 PRE SCORE", "MIST-20 POST SCORE")))  # Updated levels

# Create the plot for Groups 1 and 3 (Test Group)
plot1 <- ggplot(long_data %>% filter(GROUP %in% c(1, 3)), aes(x = Test_Time, y = Score, fill = Test_Time)) +
  geom_boxplot(outlier.colour = "red", outlier.shape = 16, outlier.size = 2) +
  facet_wrap(~ GROUP, labeller = as_labeller(group_titles)) +  # Only for Groups 1 and 3
  labs(
    title = "MIST-20 Scores Before & After Ad - Test Group\n",  # Updated title
    x = "\nMIST-20 Test Scores",  # Updated axis label
    y = "Score\n"
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, size = 14, face = "bold"),
    legend.position = "none"
  )

# Use grid.arrange to display the plot
grid.arrange(plot1)  # Display the plot for Test Groups (1 & 3)
```

```{r mist_2, tidy=TRUE, message=FALSE, warning=FALSE, results='hide', echo=FALSE, fig.align='center', results='asis'}

# Define custom labels for groups
group_titles <- c(
  "1" = "VISUAL AD", # Test Group (Visual)
  "2" = "VISUAL AD", # Control Group (Visual)
  "3" = "AUDIO AD", # Test Group (Audio)
  "4" = "AUDIO AD" # Control Group (Audio)
)

# Reshape the data to long format for easier faceting
long_data <- misinfo_filtered %>%
  # Convert both "MIST-20 PRE SCORE" and "MIST-20 POST SCORE" to numeric
  mutate(
    `MIST-20 PRE SCORE` = as.numeric(`MIST-20 PRE SCORE`),
    `MIST-20 POST SCORE` = as.numeric(`MIST-20 POST SCORE`)
  ) %>%
  select(GROUP, `MIST-20 PRE SCORE`, `MIST-20 POST SCORE`) %>%  # Updated column names here
  pivot_longer(cols = c(`MIST-20 PRE SCORE`, `MIST-20 POST SCORE`), 
               names_to = "Test_Time", 
               values_to = "Score") %>%
  mutate(Test_Time = factor(Test_Time, levels = c("MIST-20 PRE SCORE", "MIST-20 POST SCORE")))  # Updated levels

# Create the plot for Groups 2 and 4 (Control Group)
plot2 <- ggplot(long_data %>% filter(GROUP %in% c(2, 4)), aes(x = Test_Time, y = Score, fill = Test_Time)) +
  geom_boxplot(outlier.colour = "red", outlier.shape = 16, outlier.size = 2) +
  facet_wrap(~ GROUP, labeller = as_labeller(group_titles)) +  # Only for Groups 2 and 4
  labs(
    title = "MIST-20 Scores Before & After Ad - Control Group\n",  # Updated title
    x = "\nMIST-20 Test Scores",  # Updated axis label
    y = "Score\n"
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, size = 14, face = "bold"),
    legend.position = "none"
  )

# Use grid.arrange to display the plot
grid.arrange(plot2)  # Display the plot for Control Groups (2 & 4)
```

```{r itmist_box_1, tidy=TRUE, message=FALSE, warning=FALSE, results='hide', echo=FALSE, fig.align='center', results='asis'}

# Define custom labels for groups
group_titles <- c(
  "1" = "VISUAL AD", # Test Group (Visual)
  "2" = "VISUAL AD", # Control Group (Visual)
  "3" = "AUDIO AD", # Test Group (Audio)
  "4" = "AUDIO AD" # Control Group (Audio)
)

# Reshape the data to long format for easier faceting
long_data <- misinfo_filtered %>%
  # Convert both "ITMIST PRE SCORE" and "ITMIST POST SCORE" to numeric
  mutate(
    `ITMIST PRE SCORE` = as.numeric(`ITMIST PRE SCORE`),
    `ITMIST POST SCORE` = as.numeric(`ITMIST POST SCORE`)
  ) %>%
  select(GROUP, `ITMIST PRE SCORE`, `ITMIST POST SCORE`) %>%  # Updated column names here
  pivot_longer(cols = c(`ITMIST PRE SCORE`, `ITMIST POST SCORE`), 
               names_to = "Test_Time", 
               values_to = "Score") %>%
  mutate(Test_Time = factor(Test_Time, levels = c("ITMIST PRE SCORE", "ITMIST POST SCORE")))  # Updated levels

# Create the plot for Groups 1 and 3 (Test Group)
plot1 <- ggplot(long_data %>% filter(GROUP %in% c(1, 3)), aes(x = Test_Time, y = Score, fill = Test_Time)) +
  geom_boxplot(outlier.colour = "red", outlier.shape = 16, outlier.size = 2) +
  facet_wrap(~ GROUP, labeller = as_labeller(group_titles)) +  # Only for Groups 1 and 3
  labs(
    title = "ITMIST Scores Before & After Ad - Test Group\n",  # Updated title for ITMIST
    x = "\nITMIST Test Scores",  # Updated axis label for ITMIST
    y = "Score\n"
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, size = 14, face = "bold"),
    legend.position = "none"
  )

# Use grid.arrange to display the plot
grid.arrange(plot1)  # Display the plot for Test Groups (1 & 3)
```

```{r itmist_box_2, tidy=TRUE, message=FALSE, warning=FALSE, results='hide', echo=FALSE, fig.align='center', results='asis'}

# Define custom labels for groups
group_titles <- c(
  "1" = "VISUAL AD", # Test Group (Visual)
  "2" = "VISUAL AD", # Control Group (Visual)
  "3" = "AUDIO AD", # Test Group (Audio)
  "4" = "AUDIO AD" # Control Group (Audio)
)

# Reshape the data to long format for easier faceting
long_data <- misinfo_filtered %>%
  # Convert both "ITMIST PRE SCORE" and "ITMIST POST SCORE" to numeric
  mutate(
    `ITMIST PRE SCORE` = as.numeric(`ITMIST PRE SCORE`),
    `ITMIST POST SCORE` = as.numeric(`ITMIST POST SCORE`)
  ) %>%
  select(GROUP, `ITMIST PRE SCORE`, `ITMIST POST SCORE`) %>%  # Updated column names here
  pivot_longer(cols = c(`ITMIST PRE SCORE`, `ITMIST POST SCORE`), 
               names_to = "Test_Time", 
               values_to = "Score") %>%
  mutate(Test_Time = factor(Test_Time, levels = c("ITMIST PRE SCORE", "ITMIST POST SCORE")))  # Updated levels

# Create the plot for Groups 2 and 4 (Control Group)
plot2 <- ggplot(long_data %>% filter(GROUP %in% c(2, 4)), aes(x = Test_Time, y = Score, fill = Test_Time)) +
  geom_boxplot(outlier.colour = "red", outlier.shape = 16, outlier.size = 2) +
  facet_wrap(~ GROUP, labeller = as_labeller(group_titles)) +  # Only for Groups 2 and 4
  labs(
    title = "ITMIST Scores Before & After Ad - Control Group\n",  # Updated title for ITMIST
    x = "\nITMIST Test Scores",  # Updated axis label for ITMIST
    y = "Score\n"
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, size = 14, face = "bold"),
    legend.position = "none"
  )

# Use grid.arrange to display the plot
grid.arrange(plot2)  # Display the plot for Control Groups (2 & 4)
```

```{r sentiment, tidy=TRUE, message=FALSE, warning=FALSE, results='hide', echo=FALSE, fig.align='center', results='asis'}

# Load necessary libraries
library(ggplot2)
library(dplyr)
library(tidyr)  # Ensure tidyr is loaded for drop_na()

# Prepare data for stacked bar chart, removing NA values only for this analysis
stacked_data <- misinfo_filtered %>%
  count(GROUP, SENTIMENT) %>%
  group_by(GROUP) %>%
  mutate(percentage = n / sum(n) * 100) %>%  # Convert to percentage
  ungroup()

# Ensure GROUP is a factor for proper ordering
stacked_data$GROUP <- factor(stacked_data$GROUP, levels = c("1", "2", "3", "4"))

# Convert SENTIMENT to a factor with labels
stacked_data$SENTIMENT <- factor(stacked_data$SENTIMENT, levels = c(1, 2, 3), labels = c("Positive", "Neutral", "Negative"))

# Custom colors for sentiment levels
custom_colors <- c("Positive" = "skyblue", "Neutral" = "orange", "Negative" = "red")

# Define labels for groups
group_titles <- c(
  "1" = "Visual Ad\n(Test Group)",
  "2" = "Visual Ad\n(Control Group)",
  "3" = "Audio Ad\n(Test Group)",
  "4" = "Audio Ad\n(Control Group)"
)

# Create the stacked bar chart
stacked_bar_chart <- ggplot(stacked_data, aes(x = GROUP, y = percentage, fill = SENTIMENT)) +
  geom_bar(stat = "identity", color = "black") +  # Stacked bars with black borders
  geom_text(aes(label = paste0(round(percentage, 1), "%")), 
            position = position_stack(vjust = 0.5),  # Position labels in center of bars
            color = "black", size = 4) +  # Adjust label size and color
  labs(
    title = "Sentiment of Ad by Group",
    x = "\nGroup",
    y = "Percentage\n",
    fill = "Sentiment"
  ) +
  scale_x_discrete(labels = group_titles) +  # Map numeric groups to names
  scale_fill_manual(values = custom_colors) +  # Apply colors
  theme_minimal() + 
  theme(
    plot.title = element_text(hjust = 0.5, size = 14, face = "bold"),  # Center and style the title
    #axis.text.x = element_text(angle = 30, hjust = 1),  # Tilt x-axis labels for readability
    legend.position = "right",  # Keep legend visible
    legend.title = element_text(face = "bold"),
    legend.text = element_text(size = 10)
  )

# Print the stacked bar chart
print(stacked_bar_chart)

# Save the plot as a PNG file
ggsave("sentiment_of_ad.png", plot = stacked_bar_chart, width = 8, height = 6)
```

\

```{r answer_length_2, tidy=TRUE, message=FALSE, warning=FALSE, results='hide', echo=FALSE, fig.align='center', results='asis'}

#grid.arrange(
#  arrangeGrob(
#    plot3, plot4,
#    nrow = 1
#  ),
#  shared_legend,
#  nrow = 2,
#  heights = c(4, 2)  # Adjust height ratios for better spacing
#)

# heights = c(4, 1)  # Original ratio
```

```{r backup, tidy=TRUE, message=FALSE, warning=FALSE, results='hide', echo=FALSE, fig.align='center', results='asis'}

# This was my original for what I plotted above

# Arrange the last two pie charts with the shared legend
#grid.arrange(
#  arrangeGrob(
#    pie_charts[["Group_3"]] + theme(legend.position = "none"),
#    pie_charts[["Group_4"]] + theme(legend.position = "none"),
#    nrow = 1
#  ),
#  shared_legend,
#  nrow = 2,
#  heights = c(4, 1)  # Adjust height ratio
#)
```

```{r test_pies, tidy=TRUE, message=FALSE, warning=FALSE, results='hide', echo=FALSE}

# These were just test pie charts which only displays each plot individually

library(ggplot2)
library(dplyr)

# Create an empty list to store pie charts
pie_charts <- list()

# Define a vector to map numeric values to descriptions for CHANGED_VIEWS_QQ1
view_labels <- c("1" = "View stayed about the same",
                 "2" = "View had some/moderate change",
                 "3" = "View significantly changed")

# Custom colors for each section (You can change these to any colors you prefer)
#custom_colors <- c("skyblue", "orange", "red")
custom_colors <- c("skyblue", "lightgreen", "coral")

# Loop through each GROUP value and create pie charts
for (group_value in unique(misinfo_filtered$GROUP)) {
  
  # Prepare data for pie chart
  pie_data <- misinfo_filtered %>%
    filter(GROUP == group_value) %>%
    count(CHANGED_VIEWS_QQ1) %>%
    mutate(percentage = n / sum(n) * 100,
           label = paste0(round(percentage, 1), "%"))  # Create labels with percentage signs
  
  # Ensure CHANGED_VIEWS_QQ1 is a factor
  pie_data$CHANGED_VIEWS_QQ1 <- factor(pie_data$CHANGED_VIEWS_QQ1, levels = c(1, 2, 3))
  
  # Generate pie chart with custom colors and black borders
  p <- ggplot(pie_data, aes(x = "", y = n, fill = CHANGED_VIEWS_QQ1)) +
    geom_bar(stat = "identity", width = 1, color = "black") +  # Add black border around sections
    coord_polar(theta = "y") +
    geom_text(aes(label = label), position = position_stack(vjust = 0.5), color = "black", size = 5) +  # Add labels inside the pie
    labs(title = paste("Pie Chart of CHANGED_VIEWS_QQ1 for GROUP", group_value),
         fill = "Change in Answer") +  # Rename the legend
    scale_fill_manual(values = custom_colors, labels = view_labels) +  # Apply custom colors
    theme_void() +  # Remove unnecessary gridlines
    theme(legend.position = "right")  # Ensure the legend is visible
  
  # Store the plot in the list with the group value as the name
  pie_charts[[paste0("Group_", group_value)]] <- p
}

# View stored pie charts
#pie_charts[["Group_1"]]  # Example: Display pie chart for Group 1
#pie_charts[["Group_2"]]  # Example: Display pie chart for Group 2
#pie_charts[["Group_3"]]  # Example: Display pie chart for Group 3
#pie_charts[["Group_4"]]  # Example: Display pie chart for Group 4
```

```{r participant info, tidy=TRUE, message=FALSE, warning=FALSE, results='hide', echo=FALSE}

# Participants

#Control Group (Audio): 21 (42.98%)
#Control Group (Visual): 22 (44%)
#Test Group (Audio): 28 (57.14%)
#Test Group (Visual): 28 (56%)

#Total: 99
```
